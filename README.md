# This project has been created as part of the 42 curriculum by <[yousenna](https://github.com/youssenna)>

## ðŸ“Œ Description

**push_swap** is a sorting algorithm project from the 42 curriculum.  
The objective is to sort a stack of integers using a limited set of operations and **as few moves as possible**.

The project also includes **checker** (bonus part), a program that verifies whether the list of instructions generated by `push_swap` correctly sorts the stack.

The project uses two stacks:
- **Stack A**: initially contains all numbers
- **Stack B**: initially empty

---

## ðŸŽ¯ Project Goals

- Sort **stack A** in ascending order
- Use **only the allowed operations**
- Minimize the number of operations
- Handle **any valid `int` range**
- Reject invalid input (duplicates, non-numbers, overflow)

---

## ðŸ”§ Allowed Operations

| Operation | Description |
|----------|-------------|
| `sa` | Swap the first two elements of stack A |
| `sb` | Swap the first two elements of stack B |
| `ss` | `sa` and `sb` at the same time |
| `pa` | Push the top of B to A |
| `pb` | Push the top of A to B |
| `ra` | Rotate stack A |
| `rb` | Rotate stack B |
| `rr` | `ra` and `rb` at the same time |
| `rra` | Reverse rotate stack A |
| `rrb` | Reverse rotate stack B |
| `rrr` | `rra` and `rrb` at the same time |

---

## ðŸ§  Algorithm

This implementation is based on a **cost-based Turk Algorithm**.

### Strategy

1. Push elements from **stack A to stack B** until only 3 remain in A
2. Sort the 3 remaining elements in stack A
3. For each element in stack B:
   - Find its **target position** in stack A
   - Calculate the **cost** (number of operations)
   - Use **simultaneous rotations (`rr`, `rrr`)** when possible
4. Push all elements back to stack A in the correct order
5. Rotate stack A so the smallest number is on top

This approach balances simplicity and efficiency.

---

## ðŸ“Š Performance

Average results:
- **~650 operations for 100 numbers**
- **~5400 operations for 500 numbers**

The program fully validates the mandatory part and is optimized for the bonus thresholds.

---

## ðŸ“¥ Installation

```bash
git clone https://github.com/youssenna/push_swap.git
cd push_swap
```

## ðŸ› ï¸ Compilation
```bash
make
```

For the bonus (checker):
```
make bonus
```

## â–¶ï¸ Usage

```
./push_swap 3 2 1
```

Output

```sa
rra
````

## ðŸ§ª Checker (Bonus)

Generate random numbers:

```bash
ARG=$(seq -50000 50000 | shuf -n 10 | tr '\n' ' ')
```

Run push_swap:
```
./push_swap $ARG
```

copie operations

run
```
./checker $ARG
```
Then past he opeartion that's you copyied

Expected result:

`OK`


To count the number of operations:
```
./push_swap $ARG | wc -l
```
## âœ… Checker Output

- OK â†’ stack sorted correctly

- KO â†’ stack not sorted

- Error â†’ invalid input or invalid operation

## ðŸš« Error Handling

- The program prints Error to stderr and exits if:

- Input contains duplicates

- Input is not a valid integer

- Integer overflow occurs

- An invalid operation is detected (checker)

## ðŸ“ Project Structure

push_swap/

â”œâ”€â”€ checker.h

â”œâ”€â”€ checker_main.c

â”œâ”€â”€ checker_utils.c

â”‚

â”œâ”€â”€ get_next_line/

â”‚   â”œâ”€â”€ get_next_line.c

â”‚   â”œâ”€â”€ get_next_line_utils.c

â”‚   â””â”€â”€ get_next_line.h

â”‚

â”œâ”€â”€ libft/

â”‚   â”œâ”€â”€ libft.a

â”‚   â””â”€â”€ (libft source files)

â”‚

â”œâ”€â”€ operation.c

â”œâ”€â”€ operation2.c

â”‚

â”œâ”€â”€ operation_checker.c

â”œâ”€â”€ operation2_checker.c

â”‚

â”œâ”€â”€ push_swap.h

â”œâ”€â”€ push_swap_main.c

â”‚

â”œâ”€â”€ turck_algo_main.c

â”œâ”€â”€ turck_algo_utils1.c

â”œâ”€â”€ turck_algo_utils2.c

â”œâ”€â”€ turck_algo_utils3.c

â”‚

â”œâ”€â”€ push_swap_tester/

â”‚   â””â”€â”€ (testing scripts)

â”‚

â”œâ”€â”€ Makefile

â””â”€â”€ README.md

## ðŸ§© What I Learned

- Stack-based sorting algorithms

- Cost-based optimization strategies

- Linked list manipulation

- Robust input parsing and validation

- Writing a reliable checker

- Low-level memory management in C

## ðŸ¤– How AI Helped Me

During this project, I used AI tools as a learning assistant to:

- Understand complex algorithms like the Turk Algorithm

- Debug tricky logical issues

- Review and clarify C syntax and memory handling

- Suggest strategies for optimizing operations

>AI did not write the code for meâ€”it helped me understand, plan, and improve my implementation. This allowed me to learn faster and develop a deeper understanding of stacks, sorting, and low-level C programming.


## Resources
- I explain my algo on this excalidrow web site [click her](https://excalidraw.com/#room=72fdc6c9d1e6cc001678,SYav_e0vI78rrSlLDA5PGA).

- this article help me to understand turck algorithem [click her](https://pure-forest.medium.com/push-swap-turk-algorithm-explained-in-6-steps-4c6650a458c0).
## Author

**Youssef Ennajar** - [LinkedIn](https://www.linkedin.com/in/youssef-ennajar-213985253/) | [GitHub](https://github.com/youssenna)

pb
pb
pb
pb
pb
pb
pb
ra
pa
ra
pa
ra
pa
rra
rra
pa
rrb
pa
ra
ra
ra
pa
ra
pa
ra
ra
âžœ  push git:(main) âœ— ./checker $ARG                                                                          
pb
pb
pb
pb
pb
pb
pb
ra
pa
ra
pa
ra
pa
rra
rra
pa
rrb
pa
ra
ra
ra
pa
ra
pa
ra
ra
OK
âžœ  push git:(main) âœ— ARG=$(seq -50000 50000 | shuf -n 100 |  tr '\n' ' ') ; ./push_swap $ARG 
